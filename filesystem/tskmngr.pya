import psutil
import pygame
import os
import time

# Color definitions
DARK_GRAY = (50, 50, 50)
GRAY = (100, 100, 100)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
SPARKLINE_COLOR = (100, 200, 100)
SECTION_BG = (60, 60, 60)
SEPARATOR = (80, 80, 80)
HEADER_COLOR = (180, 255, 180)

def get_initial_cpu_load():
    try:
        # Get initial CPU load with a small interval to ensure accurate reading
        return psutil.cpu_percent(interval=0.1) / 100.0
    except Exception as e:
        print(f"Error getting initial CPU load: {str(e)}")
        return 0.0

def init(rect):
    global buttons, font, last_metrics, self_window, last_perf_update, load_history, last_load_update
    font = pygame.font.Font(None, 24)
    buttons = []
    last_metrics = {'cpu': 0, 'memory': 0, 'window_count': 0, 'fps': 0}
    last_perf_update = pygame.time.get_ticks()
    last_load_update = time.time()
    self_window = None
    
    # Get initial CPU load
    initial_load = get_initial_cpu_load()
    load_history = [initial_load] * 30  # Initialize with current CPU load
    
    # Store reference to our own window
    for window in api.windows:
        if window.title.startswith("PyOS App - tskmngr"):
            self_window = window
            break

def get_system_metrics():
    try:
        # Get CPU load (non-blocking)
        cpu_load = psutil.cpu_percent(interval=None) / 100.0
        
        # Get memory info (with error handling)
        try:
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
        except Exception as e:
            print(f"Error getting memory info: {str(e)}")
            memory_percent = 0
            
        return cpu_load, memory_percent
    except Exception as e:
        print(f"Error getting system metrics: {str(e)}")
        return 0, 0

def get_system_load():
    global load_history, last_load_update
    current_time = time.time()
    
    # Only update load every 10 seconds
    if current_time - last_load_update < 10.0:
        return sum(load_history) / len(load_history) * 100
        
    try:
        # Get system load
        cpu_load, _ = get_system_metrics()
            
        # Update load history
        load_history.pop(0)
        load_history.append(cpu_load)
        last_load_update = current_time
        
        # Calculate average load
        avg_load = sum(load_history) / len(load_history)
        return avg_load * 100  # Convert to percentage
    except Exception as e:
        print(f"Error getting system load: {str(e)}")
        return 0

def draw_sparkline(screen, x, y, width, height, values):
    if not values:
        return
        
    # Find min and max values
    min_val = min(values)
    max_val = max(values)
    if max_val == min_val:
        max_val = min_val + 1  # Prevent division by zero
        
    # Calculate points
    points = []
    for i, val in enumerate(values):
        x_pos = x + (i * width) // (len(values) - 1)
        y_pos = y + height - ((val - min_val) * height) // (max_val - min_val)
        points.append((x_pos, y_pos))
    
    # Draw lines
    if len(points) > 1:
        pygame.draw.lines(screen, SPARKLINE_COLOR, False, points, 2)

def main(screen, rect):
    global buttons, last_metrics, self_window, last_perf_update
    buttons = []  # Clear buttons each frame
    current_time = pygame.time.get_ticks()
    
    # Update performance metrics every 2 seconds
    if current_time - last_perf_update > 2000:
        metrics = api.get_performance()
        if metrics:
            last_metrics = metrics
        last_perf_update = current_time
    
    # Padding and section sizes
    pad = 20
    section_height = 110
    section_width = rect.width - 2 * pad
    x0 = rect.x + pad
    y = rect.y + pad
    
    # --- System Load Section ---
    pygame.draw.rect(screen, SECTION_BG, (x0, y, section_width, section_height), border_radius=8)
    header_font = pygame.font.SysFont('Arial', 20, bold=True)
    font = pygame.font.SysFont('Arial', 16)
    
    # Section header
    header = header_font.render("System Load", True, HEADER_COLOR)
    screen.blit(header, (x0 + 10, y + 8))
    
    # System Load value
    system_load = get_system_load()
    load_text = font.render(f"{system_load:.1f}%", True, WHITE)
    screen.blit(load_text, (x0 + section_width - 70, y + 12))
    
    # System Load bar
    bar_y = y + 40
    bar_width = section_width - 40
    bar_height = 15
    bar_rect = pygame.Rect(x0 + 10, bar_y, bar_width, bar_height)
    pygame.draw.rect(screen, GRAY, bar_rect, border_radius=6)
    filled_width = int(bar_width * system_load / 100)
    filled_rect = pygame.Rect(x0 + 10, bar_y, filled_width, bar_height)
    pygame.draw.rect(screen, GREEN if system_load < 80 else RED, filled_rect, border_radius=6)
    
    # Sparkline label
    sparkline_label = font.render("5 min load trend", True, (180, 180, 180))
    screen.blit(sparkline_label, (x0 + 10, bar_y + 22))
    # Sparkline
    sparkline_height = 30
    draw_sparkline(screen, x0 + 130, bar_y + 25, bar_width - 120, sparkline_height, load_history)
    
    # Separator
    y += section_height + 10
    pygame.draw.line(screen, SEPARATOR, (x0, y), (x0 + section_width, y), 2)
    y += 10
    
    # --- Memory Usage Section ---
    pygame.draw.rect(screen, SECTION_BG, (x0, y, section_width, 70), border_radius=8)
    header = header_font.render("Memory Usage", True, HEADER_COLOR)
    screen.blit(header, (x0 + 10, y + 8))
    _, memory_percent = get_system_metrics()
    mem_text = font.render(f"{memory_percent:.1f}%", True, WHITE)
    screen.blit(mem_text, (x0 + section_width - 70, y + 12))
    bar_y = y + 40
    bar_rect = pygame.Rect(x0 + 10, bar_y, bar_width, bar_height)
    pygame.draw.rect(screen, GRAY, bar_rect, border_radius=6)
    filled_width = int(bar_width * memory_percent / 100)
    filled_rect = pygame.Rect(x0 + 10, bar_y, filled_width, bar_height)
    pygame.draw.rect(screen, GREEN if memory_percent < 80 else RED, filled_rect, border_radius=6)
    
    # Separator
    y += 70 + 10
    pygame.draw.line(screen, SEPARATOR, (x0, y), (x0 + section_width, y), 2)
    y += 10
    
    # --- Active Windows Section ---
    pygame.draw.rect(screen, SECTION_BG, (x0, y, section_width, rect.height - y + rect.y - pad), border_radius=8)
    header = header_font.render("Active Windows", True, HEADER_COLOR)
    screen.blit(header, (x0 + 10, y + 8))
    font = pygame.font.SysFont('Arial', 14)
    headers = font.render("Window Title", True, WHITE)
    screen.blit(headers, (x0 + 20, y + 40))
    
    # List all windows
    try:
        windows = list(api.windows)
    except Exception as e:
        print(f"Error getting windows: {str(e)}")
        windows = []
    buttons.clear()
    y_win = y + 70
    for window in windows:
        if window == self_window:
            continue
        title = window.title
        if len(title) > 40:
            title = title[:37] + "..."
        title_rect = pygame.Rect(x0 + 20, y_win, section_width - 120, 22)
        mouse_pos = pygame.mouse.get_pos()
        title_color = (200, 200, 200) if title_rect.collidepoint(mouse_pos) else WHITE
        text = font.render(title, True, title_color)
        screen.blit(text, (x0 + 20, y_win))
        # Kill button
        button_rect = pygame.Rect(x0 + section_width - 80, y_win, 60, 22)
        button_color = (255, 0, 0) if button_rect.collidepoint(mouse_pos) else (100, 0, 0)
        pygame.draw.rect(screen, button_color, button_rect, border_radius=6)
        kill_text = font.render("Kill", True, WHITE)
        text_rect = kill_text.get_rect(center=button_rect.center)
        screen.blit(kill_text, text_rect)
        buttons.append({'rect': button_rect, 'window': window, 'title_rect': title_rect})
        y_win += 30

def handle_event(event):
    global buttons
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:  # Left click
        mouse_pos = pygame.mouse.get_pos()
        
        # Check each button
        for button in buttons:
            # Check if kill button was clicked
            if button['rect'].collidepoint(mouse_pos):
                try:
                    window = button['window']
                    # Add window to the window manager's remove list
                    api._wm.windows_to_remove.append(window)
                    # Also call close() to ensure proper cleanup
                    window.close()
                except Exception as e:
                    print(f"Error closing window: {str(e)}")
                break
            # Check if title was clicked (switch to window)
            elif button['title_rect'].collidepoint(mouse_pos):
                try:
                    window = button['window']
                    # Bring window to front
                    api.bring_to_front(window)
                except Exception as e:
                    print(f"Error switching to window: {str(e)}")
                break
